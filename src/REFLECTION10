1. (lambda (z) (lambda (x)  (- z (+ x y))))

captured: z
primitive: +
global name: y
local: x

2.  Line 55 of closure-convert.sml, since 
free_expressions is the names free in the lambda
and these are the names captured by the new closure. When
the free function is called, if there is a global variable in
the set of free_expressions, it does not get included in the set of free
variables since globals are not considered free, although global variables
are technically free.

3. lines 47-53 of embedkn.sml

4. Lines 306-312 of vmrun.c

5. lines 124, 125 of knormalize.sml. We use the nbRegs function with a continuation
that uses the list of registers allocated inside the captured variables of the 
closure.

6. We did have a bug in which we were not correctly identifying
the free variables in the lambda and line 110 of our code  created a failure since
the captured variable was not bound the environment and therefore could not be looked up.

7. 

8. lines 127-139 of