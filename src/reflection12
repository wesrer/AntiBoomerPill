
***RESUBMITTED BC WE FIXED BUGS AND OPTIMIZED***

1.  We pushed solution.scm, which has functions from 105 implemented. 
    They test the following:
      1. allocation of cons cells
      2. list operations
      3. use of primitives
      4. globals
      They do not test closures.
  
2. One benchmark I pushed was TAK.scm, and it tests function calls and arithmetic. I know
  this because the tak function makes 63,507 function calls, according to the gabriel lisp textbook,
  and it uses arithmetic primitives. It does not do much else.

3. Production Benchmarks:
    - derivative.py
    - takl.py
    - tak.py

4. 
  The following are bugs we are aware of/ things we still need to implement
  1. record not implemented
  2. error primitive not implemented
  3. two of erica's tests were not passing, so must investigate
  4. norman's benchmark tests don't pass (not sure whycd src)


5.
We chose a gamma of 4.0 because it achieved a sweet spot in the tradeoff
between space and time. Using a more conservative gamma, we were able
to use very little space, but the time was 2.58s. By changing our gamma to
4.0, we were able to get close enough to our best time without an enormous
increase in space that comes with using a larger gamma.

  Our trials are as follows:
Gamma   Space  (b)  Time (s)    Decrease in Time   Increase in Space
2.2     1,120,000   2.58          0.0                0
3.0     1,365,000   2.48        - 0.1              + 245,000
3.4     1,365,000   2.49        - 0.09             + 245,000
3.7     1,365,000   2.47        - 0.11             + 245,000
4.0     1,820,000   2.37        - 0.21             + 700,000
5.0     2,275,000   2.30        - 0.28             + 1,115,000
6.0     2,940,000   2.26        - 0.32             + 1,820,000
10.0    4,550,000   2.24        - 0.34             + 3,430,000

6. 
 14 benchmarks run without errors.
Our system seems to be around the same as others. Most tests took 
less than a second.

7. One thing we did to make our performance better was 
to stop caching all the registers at the beginning of
every instruction decoding. This was unecessary. We were also accessing
the current_fun member of the vmstate on every decode. By removing these,
we were able to get the list_permute benchmark to run in 16.57 seconds instead
of 22.35.

8. We ran erica's takl.scm and it took 3.62 seconds as opposed to our ruby 
benchmark which took 0.14 seconds. We used arrays in ruby, which
can be mutated directly, so it makes sense that this would be much faster.
We will be investigating further as we continue to optimize our vm.